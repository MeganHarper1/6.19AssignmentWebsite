<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Agile VS Waterfall</title>
    <link type="text/css" rel="stylesheet" href="styleSheet.css">
</head>



<body>
<div class="nav">

<ul>
    <li><a href="agileMethodology.html">Agile</a></li>
    <li><a href="waterfallMethodology.html">Waterfall</a></li>
    <li><a href="agileVSwaterfall.html">Agile vs Waterfall</a></li>
    <li><a href="mobProgramming.html">Pair vs Mob programming</a></li>
    <li><a href="radMethodology.html">Pair vs Mob programming</a></li>
</ul>



</div>

<div class="container">
    <h1>Agile VS Waterfall</h1>

    <p>
        Not 1 methodology is suitable for every project or nature of work within a team.
        <br>
        There are upsides and downsides of all of the methodologies:
        <br>
    </p>
    <h2>Agile Advantages:</h2>
    <p>
    <br>
    - You can deploy software quicker, so your customer can get value sooner rather than later
    <br>
    - You waste fewer resources because you always work on up-to-date tasks
    <br>
    - You can better adapt to change and respond faster
    <br>
    - Faster turnaround times
    <br>
    - You can detect and fix issues and defects faster
    <br>
    - You spend less time on bureaucracy and busywork
    <br>
    - There's a big community of Agile practitioners with whom you can share knowledge
    <br>
    - You can get immediate feedback (which also improves team morale)
    <br>
    - Developers can improve their skills based on QA feedback
    <br>
    - You don't have to worry about premature optimization
    <br>
    - You can experiment and test ideas because its costs are low
    <br>
    </p>

    <h2>Agile Disadvantages:</h2>
    <p>

    <br>
    - Documentation tends to get sidetracked, which makes it harder for new members to get up to speed
    <br>
    - It's more difficult to measure progress than it is in Waterfall because progress happens across several cycles
    <br>
    - Agile demands more time and energy from everyone because developers and customers must constantly interact with each other
    <br>
    - When developers run out of work, they can't work on a different project since they'll be needed soon
    <br>
    - Projects can become ever-lasting because there's no clear end
    <br>
    - Scope creep and experience rot
    <br>
    - Clients who work on a specified budget or schedule can't know how much the project will actually cost, which makes for a very complicated sales cycle ("Until iteration ends," is not something clients like to hear)
    <br>
    - Product lacks overall design, both from a UX and architecture point of view, which leads to problems the more you work on the product
    <br>
    - Teams can get sidetracked into delivering new functionalities at the expense of technical debt, which increases the amount of unplanned work
    <br>
    - Features that are too big to fit into one or even several cycles are avoided because they don't fit in nicely into the philosophy
    <br>
    - You need a long-term vision for the product and actively work on communicating it
    <br>
    - Products lack cohesion, and the user journey is fragmented because the design is fragmented. The more time passes, the more disjointed the software ends up becoming
    <br>
    - Short cycles don't leave enough time for the design thinking process, so designers have to redevelop the experience over and over due to negative feedback
    <br>
    </p>

    <h2>Waterfall Advantages:</h2>
    <p>
    <br>
    - Simple and easy to understand and use
    <br>
    - Easy to manage due to the rigidity of the model. Each phase has specific deliverables and a review process.
    <br>
    - Phases are processed and completed one at a time.
    <br>
    - Works well for smaller projects where requirements are very well understood.
    <br>
    - Clearly defined stages.
    <br>
    - Well understood milestones.
    <br>
    - Easy to arrange tasks.
    <br>
    - Process and results are well documented.
    <br>
    </p>

    <h2>Waterfall Disadvantages:</h2>
    <p>
    <br>
    - No working software is produced until late during the life cycle.
    <br>
    - High amounts of risk and uncertainty.
    <br>
    - Not a good model for complex and object-oriented projects.
    <br>
    - Poor model for long and ongoing projects.
    <br>
    - Not suitable for the projects where requirements are at a moderate to high risk of changing. So, risk and uncertainty is high with this process model.
    <br>
    - It is difficult to measure progress within stages.
    <br>
    - Cannot accommodate changing requirements.
    <br>
    - Adjusting scope during the life cycle can end a project.
    <br>
    - Integration is done as a "big-bang. at the very end, which doesn't allow identifying any technological or business bottleneck or challenges early.
    </p>
</div>

</body>
</html>